## Software Engineering 
It involves the application of engineering principles 
in designing, developing, maintaining, testing and evaluating
software. To ensure that high quality softwares are made that meets users needs,
is efficient, maintainable and reliable.

## Difference Between Software Engineering and Traditional Programing
The differnce is primarily in the approach;
while software engineeeing adopts a broader approach 
which involves collaboration, applying best engineering principles,
maintenability and overral best practice,
traditional programing basically involves writing code to solve a 
particular problem.


## Software Development Lifecycle
Software development lifecycle refers to a structured process used by 
software engineers to desing, develop test and deploy software products, so
as to deliver high quality software products that meets or surpasses the 
user's expectations within given time and budget.


The key phases of software development lifecycle involves:
1. planning:
    Objective: Determine the scope and purpose of the software project.
    Activities: Define project goals, perform feasibility studies, 
    estimate costs and resources, and create a project plan.
2. Requirements Analysis:
    Objective: Gather and document the software requirements from stakeholders.
    Activities: Conduct interviews, surveys, and meetings to understand user needs and 
    system requirements. Create detailed requirements documentation.
3. System Design:
   Objective: Define the software architecture and design the system components.
   Activities: Create system models, diagrams (like UML diagrams), and design specifications 
   that outline how the software will meet the requirements.
4. Implementation(coding):
   Objective: Convert the system design into executable code.
   Activities: Write and compile code, adhere to coding standards, 
   and perform unit testing to ensure individual components work as intended.
5. Testing:
   Objective: Verify that the software works as intended and is free of defects.
   Activities: Conduct various tests, including unit testing, integration testing, system testing, 
   and acceptance testing. Identify and fix bugs.
6. Maintenance:
   Objective: Ensure the software continues to operate correctly and efficiently after deployment.
   Activities: Perform ongoing maintenance tasks such as bug fixing, performance optimization, updates, 
   and enhancements based on user feedback and changing requirements.

Differnce between Agile and Waterfall Models of Software Development Lifecycle
### Agile:
Emphasizes flexibility, customer collaboration, and iterative development.
Features short development cycles called sprints.
Popular methodologies include Scrum and Kanban.

### Waterfall:
Linear and sequential approach.
Each phase must be completed before the next begins.
Suitable for projects with well-defined requirements.


## Requirement Engineering:
This involves the process of documenting, defining and
maintaining the requirements of a software system.

## Process of Requirements Engineering
1. Requirements Elicitation: This is the initial phase where requirements are gathered from stakeholders. Techniques used in this phase include interviews, questionnaires, surveys, observation, document analysis, and workshops. The goal is to understand what the stakeholders need and expect from the system.
2. Requirements Analysis: In this phase, the gathered requirements are examined, structured, and modeled. The aim is to detect and resolve conflicts, redundancies, and ambiguities in the requirements. Techniques such as use case diagrams, data flow diagrams, and entity-relationship diagrams are often used.
3. Requirements Specification: Here, the analyzed requirements are documented in a detailed and precise manner. The requirements are written in a specification document, often called the Software Requirements Specification (SRS). This document serves as a reference point for developers and stakeholders throughout the project.
4. Requirements Validation: This phase ensures that the documented requirements accurately represent the stakeholders' needs and expectations. Validation techniques include reviews, inspections, prototyping, and testing. The goal is to verify that the requirements are feasible, consistent, complete, and testable.
5. Requirements Management: This is an ongoing process that continues throughout the software development lifecycle. It involves tracking changes to requirements, managing versions, maintaining traceability, and ensuring that all changes are communicated to all stakeholders. Requirements management tools are often used to facilitate this process.

## Importance of Requirements Engineering
1. Clarity and Understanding: Proper requirements engineering ensures that there is a clear and shared understanding of what the system should do. This reduces misunderstandings and miscommunications among stakeholders and the development team.
2. Scope Management: Clearly defined requirements help in managing the scope of the project. It prevents scope creep, where additional features and changes are introduced without proper evaluation and approval, which can lead to project delays and cost overruns.
3. Risk Reduction: Identifying and analyzing requirements early helps in identifying potential risks and issues that might affect the project. This proactive approach allows for risk mitigation strategies to be developed and implemented.
4. Quality Assurance: Validating and managing requirements ensure that the final product meets the intended needs and quality standards. This leads to higher customer satisfaction and fewer defects and rework during the later stages of development.
5. Cost and Time Efficiency: By getting the requirements right from the beginning, organizations can avoid costly changes and rework. Well-defined requirements lead to more accurate project planning and estimation, contributing to better resource management and timely project completion.

## Modularity in software design 
refers to the practice of dividing a software system into distinct, self-contained units called modules. Each module encapsulates a specific functionality or a set of related functionalities, and interacts with other modules through well-defined interfaces.

## Importance of Testing in Software Development
Ensures Quality: Testing verifies that the software meets its requirements and functions correctly. It helps in identifying defects and issues early in the development process, ensuring a high-quality product.
Reduces Costs: Detecting and fixing bugs early in the development lifecycle is much cheaper than addressing them later. Effective testing reduces the overall cost of software development by minimizing the need for extensive rework.
Enhances Security: Testing helps uncover vulnerabilities and security flaws that could be exploited. This is crucial for protecting sensitive data and ensuring the software is secure from attacks.
Improves Performance: Performance testing, a part of system testing, ensures that the software performs well under expected workloads. This helps in identifying performance bottlenecks

## Levels of Software Testing

Unit Testing
Definition: Tests individual components or functions in isolation.
Purpose: Ensures each unit works correctly.
Performed By: Developers.
Tools: JUnit, pytest.

Integration Testing
Definition: Tests the interactions between integrated units or modules.
Purpose: Identifies issues from module interactions.
Performed By: Developers or testers.
Types: Big Bang, Top-Down, Bottom-Up.
Tools: Postman, Selenium.

System Testing
Definition: Tests the complete and integrated system.
Purpose: Verifies that the entire system meets requirements.
Performed By: QA team.
Types: Functional, performance, security testing.
Tools: Selenium, JMeter.

Acceptance Testingp
Definition: Final testing to determine if the system meets business needs.
Purpose: Ensures software is ready for release.
Performed By: End-users or clients.
Types: User Acceptance Testing (UAT), Alpha, Beta testing.
Tools: Cucumber, TestRail.







